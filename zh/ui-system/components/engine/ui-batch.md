# 2D 渲染组件合批规则说明

## 合批条件说明

2D 渲染组件合批的规则是节点的 layer、使用的材质、渲染组件的 blendState 和 DepthStencilState 相同、渲染组件的顶点信息要在同一个 buffer 中上传、贴图源以及贴图采样都相同才会进行合批。
下面我们就分别说明一下这些条件：
- 节点的 layer：由于 layer 会涉及到渲染与否，所以不同的 layer 之间不能进行合批
- 材质：材质相同是合批的必然要求，由于我们使用的材质实例化的机制，所以用户在设置了材质的 uniform 之后材质会进行实例化，实例化之后的材质是无法进行合批的，如果自定义材质进行了 uniform 设置之后导致此组件无法合批，之后 uniform 值使用完毕想要该组件参与合批，可将材质资源重新赋值给组件即可重新使组件参与合批（通过 CustomMaterial 接口赋值即可）
- BlendState 状态：对于部分 2D 渲染组件可以在面板上设置部分的 BlendState 值，这个值不同的话是无法进行合批的
- DepthStencilState 状态：这个值控制着组件的深度检测和模板缓冲，一般来说用户不需关心这个值的设置，这个值由引擎自动控制（用于 Mask 的效果实现）
- 顶点信息在同一个 buffer 中上传，一般情况下用户无需关心此点，顶点信息由引擎统一进行分配和管理，请参考后文的 MeshBuffer 合批说明来了解更多信息
- 贴图源和贴图采样：一般来说，这个条件是影响合批的最主要的条件，尤其对于精灵和文本来说，贴图很容易产生差别导致无法合批。引擎提供了部分方法来实现更好的合批，可参考后文。

## 合批方法说明

结合以上的合批条件说明，我们可以通过一些方法来实现更好的合批方法，需要额外说明的是，2D 渲染组件的渲染数据采集是一个基于节点树的渲染方式，而一些组件是会打断合批的，目前引擎的内置组件 Mask、Graphics 和 UIMeshRenderer 由于材质不同和数据组织方式的差异会无法与其他组件合批，而 TiledMap、Spine 和 DragonBones 这三个中间件组件遵循自己的内部合批机制，所以上述组件都无法合批，且会打断其他组件合批，需要用户进行分模块管理节点树布局，以达到更好的合批效果。

- 对于 Sprite 组件，我们提供了 [静态合图](../../../asset/auto-atlas.md) 和 [动态合图](../../../advanced-topics/dynamic-atlas.md) 两种合批方案，通过将图片纹理合并，即可在其他条件满足的情况下合批
- 对于 Label 组件，我们提供了 Bitmap 的缓存方法，通过将 Label 的纹理合图，即可实现 Sprite 和 Label 组件的合批，但请注意，使用 Bitmap 缓存方式的 Label 不可频繁变动文字内容
- 一般来说，用户通过控制材质和节点树状态配合合图方法，能够达到较好的合批效果

## MeshBuffer 合批说明

由于合批要求渲染对象的顶点在同一个 MeshBuffer 中，所以会有以下几种情况造成 MeshBuffer 切换：

在 3.4.1 以前的版本中：

- 场景中要绘制的顶点数量超过了 MeshBuffer 所能容纳的最大顶点数量（65535个顶点）

在 3.4.1 之后的版本中，由于我们采用了新的渲染数据提交设计，所以有以下几点：

- 项目设置中的 BATCHER2D_MEM_INCREMENT 的值会影响每个 MeshBuffer 可容纳的最大顶点数量。所以，这个值越大，同一个 MeshBuffer 可容纳的 2D 渲染对象也就越多，但同时，内存增加的幅度也会越大，请用户结合自身项目规模酌情设置大小
- 由于在现在的设计中，顶点信息会跟随渲染组件的整个生命周期而存在，所以如果大幅度调整了节点树结构，恰好造成了 meshBuffer 穿插的情况，则会频繁打断合批
