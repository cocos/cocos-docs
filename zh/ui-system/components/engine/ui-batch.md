# 2D 渲染组件合批规则说明

## 合批条件说明

2D 渲染组件合批的规则是节点的 layer、使用的材质、渲染组件的 blendState 和 DepthStencilState 相同、渲染组件的顶点信息要在同一个 buffer 中上传、贴图源以及贴图采样都相同才会进行合批。
下面我们就分别说明一下这些条件：
- 节点的 layer：由于 layer 会涉及到渲染与否，所以不同的 layer 之间不能进行合批
- 材质：材质相同是合批的必然要求，由于我们使用的材质实例化的机制，所以用户在设置了材质的 uniform 之后材质会进行实例化，实例化之后的材质是无法进行合批的，如果自定义材质进行了 uniform 设置之后导致此组件无法合批，之后 uniform 值使用完毕想要该组件参与合批，可将材质资源重新赋值给组件即可重新使组件参与合批（通过 CustomMaterial 接口赋值即可）
- BlendState 状态：对于部分 2D 渲染组件可以在面板上设置部分的 BlendState 值，这个值不同的话是无法进行合批的
- DepthStencilState 状态：这个值控制着组件的深度检测和模板缓冲，一般来说用户不需关心这个值的设置，这个值由引擎自动控制（用于 Mask 的效果实现）
- 顶点信息在同一个 buffer 中上传，一般情况下用户无需关心此点，顶点信息由引擎统一进行分配和管理，请参考后文的 MeshBuffer 合批说明来了解更多信息
- 贴图源和贴图采样：一般来说，这个条件是影响合批的最主要的条件，尤其对于精灵和文本来说，贴图很容易产生差别导致无法合批。引擎提供了部分方法来实现更好的合批，可参考后文。

## 合批方法说明

结合以上的合批条件说明，我们可以通过一些方法来实现更好的合批方法，需要额外说明的是，2D 渲染组件的渲染数据采集是一个基于节点树的渲染方式，而一些组件是会打断合批的，目前引擎的内置组件 Mask、Graphics 和 UIMeshRenderer 由于材质不同和数据组织方式的差异会无法与其他组件合批，而 TiledMap、Spine 和 DragonBones 这三个中间件组件遵循自己的内部合批机制，所以上述组件都无法合批，且会打断其他组件合批，需要用户进行分模块管理节点树布局，以达到更好的合批效果。

- 对于 Sprite 组件，我们提供了 [静态合图](../../../asset/auto-atlas.md) 和 [动态合图](../../../advanced-topics/dynamic-atlas.md) 两种合批方案，通过将图片纹理合并，即可在其他条件满足的情况下合批
- 对于 Label 组件，我们提供了 Bitmap 的缓存方法，通过将 Label 的纹理合图，即可实现 Sprite 和 Label 组件的合批，但请注意，使用 Bitmap 缓存方式的 Label 不可频繁变动文字内容
- 一般来说，用户通过控制材质和节点树状态配合合图方法，能够达到较好的合批效果

## MeshBuffer 合批说明

由于合批要求渲染对象的顶点在同一个 MeshBuffer 中，所以会有以下几种情况造成 MeshBuffer 切换：

在 3.4.1 以前的版本中：

- 场景中要绘制的顶点数量超过了 MeshBuffer 所能容纳的最大顶点数量（65535个顶点）

在 3.4.1 之后的版本中，由于我们采用了新的渲染数据提交设计，所以需要注意以下几点：

- 项目设置中的 BATCHER2D_MEM_INCREMENT 的值会影响每个 MeshBuffer 可容纳的最大顶点数量。所以，这个值越大，同一个 MeshBuffer 可容纳的 2D 渲染对象也就越多，但同时，内存增加的幅度也会越大，请用户结合自身项目规模酌情设置大小（KB）
- 项目设置中的 BATCHER2D_MEM_INCREMENT 单位为 KB，其与可容纳的顶点数量的关系为：在引擎内置标准顶点格式 **[vfmtPosUvColor]** ，即每个顶点占用 9 个 float 值的条件下，每个顶点占用的空间为 1 * 9 * 4 / 1024 （KB），其中 1 为顶点数，9 为 每顶点使用的数据数量， 4 为每 float 占用的 字节数， 1024 为 字节与 KB 转换单位, 所以，默认值为 144KB 的情况下，可容纳 144 * 1024 / (9 * 4）= 4096 个标准格式顶点。用户可根据自身场景规模来合理调整此值，但同一 meshBuffer 容纳的最大顶点数不可超过 65535 个，即 BATCHER2D_MEM_INCREMENT 的**最大值不可大于等于** 65536 * 9 * 4 / 1024 = 2304(KB)
- 简单描述下目前 2D 渲染使用的核心思路：

   static VB

   其主要思想为：
   - VB 固定，伴随组件的整个生命周期而存在，而决定渲染顺序的 IB 则放弃缓存，每帧进行录制。由于组件的 VB 信息多而复杂，直接保存下来可针对组件的内存段进行操作，且由于保存下来，可避免无用更新。
   - IB 每帧填充，而相对于 VB 来说，IB 的结构简单且数量较少，且直接决定渲染顺序，所以在每帧遍历时重新填充 IB 消耗较小，且无需管理复杂的缓存机制。
   - 由于 VB 固定，所以在整个组件的生命周期中，VB 会在最开始即分配好，直到组件销毁，所以在组件加载时，便会向预先分配好的 MeshBuffer 中申请好想要使用的 VB，在销毁时归还。
   - 当 MeshBuffer 已经无法分配出组件需要的 VB 时，系统便会新创建一个大小为 BATCHER2D_MEM_INCREMENT 的 MeshBuffer 来继续分配 VB。
